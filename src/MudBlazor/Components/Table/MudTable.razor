@namespace MudBlazor
@inherits MudTableBase
@typeparam T

<div @attributes="UserAttributes" class="@Classname" style="@Style">
    <CascadingValue Value="this">
        @if (ToolBarContent != null)
        {
            <MudToolBar Class="mud-table-toolbar">
                @ToolBarContent
            </MudToolBar>
        }
        <div class="mud-table-container">
            <table class="mud-table-root" style="@TableStyle">
                @if (HeaderContent != null)
                {
                    <thead class="mud-table-head">
                    <tr class="mud-table-row">
                        @HeaderContent
                    </tr>
                    </thead>
                }
                <tbody class="mud-table-body">
                    @foreach (var item in CurrentPageItems)
                    {
                        <MudTableRow Item="item" @key="item">
                            @RowTemplate(item)
                        </MudTableRow>
                    }
                </tbody>
            </table>
        </div>
        @if (PagerContent != null)
        {
            <div class="mud-table-pagination">
                    @PagerContent
            </div>
        }
    </CascadingValue>
</div>


@code
{
    // note: the MudTable code is split. Everything that has nothing to do with the type parameter of MudTable<T> is in MudTableBase

    /// <summary>
    /// 
    /// </summary>
    [Parameter] public RenderFragment<T> RowTemplate { get; set; }

    [Parameter] public IEnumerable<T> Items { get; set; }

    [Parameter] public Func<T, bool> Filter { get; set; } = null;

    [Parameter]
    public T SelectedItem
    {
        get => _selectedItem;
        set
        {
            if (Object.ReferenceEquals( SelectedItem , value))
                return;
            _selectedItem = value;
            SelectedItemChanged.InvokeAsync(value);
        }
    }
    private T _selectedItem;

    [Parameter] public EventCallback<T> SelectedItemChanged { get; set; }

    protected IEnumerable<T> FilteredItems
    {
        get
        {
            if (Filter == null)
                return Items;
            return Items.Where(Filter);
        }
    }

    protected IEnumerable<T> CurrentPageItems
    {
        get
        {
            if (@PagerContent == null)
                return FilteredItems; // we have no pagination
            return GetItemsOfPage(CurrentPage, RowsPerPage);
        }
    }

    protected IEnumerable<T> GetItemsOfPage(int n, int pageSize)
    {
        if (n < 0 || pageSize <=0)
            return new T[0];
        return FilteredItems.Skip(n * pageSize).Take(pageSize);
    }

    protected override int NumPages => (int)Math.Ceiling(FilteredItems.Count() / (double) RowsPerPage);

    public override int GetFilteredItemsCount() => FilteredItems.Count();

    public override void SetSelectedItem(object item)
    {
        SelectedItem = (T) item;
    }

}
